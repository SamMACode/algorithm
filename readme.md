## algorithm & data structure 算法与数据结构.
&emsp;&emsp; __关于排序算法部分__ ：<br>
__选择排序的算法思路__ : 选择排序算法是这样的，首先它找到数组中最小的元素，其次是将它和数组中第一个元素交换位置(如果第一个元素就是最小的元素那么它就和自己交换)。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序，这种排序算法叫做选择排序。因为它在不断地选择剩余元素之中的最小元素。<br>
```java
// 将数组array[]按照升序进行排序.
for(int i = 0; i < length; i++) {
// 将array[i]与a[i+1..length]中最小的元素交换.
int min = i;
for(int j = i+1; j < length; j++) {
  if(less(array[j], array[min])) min = j;
    // 将元素进行交换将最小的元素与内循环中在位置j处的元素进行交换.
    exch(array, i, min);
  }
}
```
__插入排序的思路__ : 与选择排序一样当前索引左边的所有元素都是有序的，但是它们的最终位置还是不确定，为了给最小的元素腾出空间，它们可能会被移动。但是当索引到达数组的右端时，数组排序就完成了。与选择排序不同的是，插入排序所需的时间取决于输入中元素的初始顺序。例如，对一个很大且其中的元素已经有序地数据进行排序将会比对随机顺序的数据或是逆序数组进行排序要快的多。
```java
for(int i = 0; i < length; i++) {
  // 将array[i]插入到a[i-1]/a[i-2]/a[i-3]..之中,确保的是i之前的数组序列是完全有序地.
  for(int j = i; j > 0 && less(array[j], array[j-1]); j--) {
    // 对数组array中的元素进行排序,当存在array[j]<array[j-1]的情况,则对其进行交换.
    exch(array, j, j-1);
  }
}
```
__希尔排序算法__ :  对于大规模乱序数组插入排序很慢，因为它只会交换相邻的元素，因此元素只能一点一点的从数组的一端移动到另一端。例如，如果数组最小的元素恰好正在数组的尽头，要将它进行挪动到正确的位置就需要N-1次移动。希尔排序是为了加快速断简单地改进了插入排序，交换不相邻的元素以对数组局部进行排序，并用最终插入排序将局部有序地数组排序。__希尔排序的思想__ : 希尔排序的思想是使数组中任意间隔为h的元素都为有序地，这样的数组被称为h有序数组。换句话说，一个h有序数组就是h个互相独立地有序数组编织在一起组成的一个数组。在进行排序的时候，如果h很大我们就能将元素移动到很远的地方，为实现更小的h有序创造方便。用这种方式，对于任意以1结尾的h序列，我们都能够将数组排序，这就是希尔排序。
```java
int h = 1;
while(h < length/3) h = 3*h + 1;     // 计算希尔shell的间隔大小 1, 4, 13, 40, 121
  // 是数组成为{h区间长度内}有序.
  while(h >= 1) {    // such as 4.
    for(int i = h; i < length; i++) {
      // 将array[i]插入到array[i-h]、array[i-2*h]、array[i-3*h]之中.
      for(int j = i; j >= h && less(array[j], array[j-h]); j -= h)
         exch(array, j, j-h);
      }
    h = h/3;
}
```






