# 常用排序算法

> 排序对于任何一个程序员来说，可能都不陌生。你学的第一个算法，可能就是排序。大部分编程语言中，都提供了排序函数。在平常的项目中，我们也经常会用到排序。排序非常重要，所以要多花一点时间来讲解经典的排序算法。

插入排序和冒泡排序的时间复杂度相同，都是`O(N^2)`，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法？

### 冒泡排序（Bubble Sort）

冒泡排序只会操作相邻的两个数据，每次冒泡都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它两互换，一次冒泡会让它至少一个元素移动它应该在的位置，重复`n`次 就完成`n`个数据排序的工作。

```java
/* 冒泡排序，a表示数组 n表示数组大小 */
public void bubbleSort(int[] a, int n) {
  if (n <= 1) return;
  for (int i = 0; i < n; ++i) {
    // 提前退出冒泡循环的标志位
    boolean flag = false;
    for (int j = 0; j < n-i-1; ++ j) {
      if (a[j] > a[j+1]) {
        int tmp = a[j];
        a[j] = a[j+1];
        a[j+1] = tmp;
        flag = true;    /* 表示有数据交换 */
      }
    }
    if (!flag) break;		// 没有数据交换提前退出 
  }
}
```

冒泡的过程只涉及相邻数据的交换操作，只需要常量级别的临时空间，所以它的空间复杂度为`O(1)`，是一个原地排序算法。其时间复杂度最坏的情况为`O(n^2)`，有序度是是数组中具有有序关系的元素对的个数。

### 插入排序（Insertion Sort）

一个有序的数组，往里面添加一个新的数据后，如何继续保持数据有序呢？很简单，只需要遍历数组 找到数据应该插入的位置将其插入既可。插入排序将数组中的数据分为两个区间，已排序区间和未排序区间。核心思想：取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。

```java
/* 插入排序 a表示数组，n表示数组大小 */
public void insertionSort(int[] a, int n) {
	if (n <= 1) return;
  for (int i = 1; i < n; ++i) {
    int value = a[i];
    int j = i -1;
    /* 查找插入的位置 */
    for (; j >= 0; --j) {
      if (a[j] > value) {
        a[j+1] = a[j];  	// 数据移动
      } else {
        break;
      }
    }
    a[j+1] = value;		// 插入数据
  }
} 
```

插入算法的运行并不需要额外的存储空间，所以空间复杂度是`O(1)`，也就是说，这是一个原地排序算法。对于相同的元素，可以选择后面出现的元素，插入到前面出现元素的后面，这样就可以保证原有的前后顺序不变。插入排序最好的时间复杂度是`O(n)`，这里是从尾到头遍历所有已经有序的数据。

### 选择排序（Selection Sort）

选择排序算法的实现有点类似于插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

```java
@Override
public void sort(Comparable[] array) {
  int length = array.length;
  for (int i = 0; i < length; i++) {
    /* 从未排序区中找出找出最小的元素的下标索引，将最小元素赋予到已排序区的最后 */
    int minIndex = i;
    for (int j = i + 1; j < length; j++) {
      if (less(array[j], array[minIndex])) {
        minIndex = j;
      }
    }
    exchange(array, i, minIndex);
  }
}
```

首先，选择排序空间复杂度为`O(1)`是一种原地排序算法。选择排序的最好情况时间复杂度、最坏情况复杂度和平均情况时间复杂度都为`O(n^2)`。为不稳定的，正是因此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。

### 归并排序（Merge Sort）

归并排序的核心思想还是比较简单的，如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并起来，这样整个数组就都有序了，归并排序使用的就是分治的思想。

分治算法一般都用递归来实现，分治是一种解决问题的处理思想，递归是一种编程技巧，这两者并不冲突。

```
merge_sort(p..r) = merge(merge_sort(p..q), merge_sort(q+1..r)) 
```

终止条件为`p >= r`不用再继续分解，以下为归并排序的伪代码：

```
/* 归并排序算法，A为数组 n表示数组大小 */
merge_sort(A, n) {
	merge_sort_c(A, 0, n-1)
}
/* 递归调用函数 */
merge_sort_c(A, p, r) {
	// 递归中止条件
	if p >= r then return
	
	// 取p到r之间的中间位置q
	q = (p + r) /2
	// 分治递归处理排序
	merge_sort_c(A, p, q)
	merge_sort_c(A, q+1, r)
	/* 将A[p...q]和A[q+1..r]合并为A[p...r] */
	merge(A[p..r], A[p...q], A[q+1...r])
}
```

`merge()`函数的伪代码如下，在合并的过程中，如果`A[p..q]`和`A[q+1..r]`之间有值相同的元素，先把 A[p...q]中的元素放入 tmp 数组。这样就保证了值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一个稳定的排序算法。

归并排序的时间复杂度任何情况下都是 O(nlogn)，看起来非常优秀。（待会儿你会发现，即便是快速排序，最坏情况下，时间复杂度也是 O(n2)。）

```
merge(A[p...r], A[p...q], A[]q+1...r) {
	var i := p, j := q+1, k := 0	// 初始化变量i, j, k
  var tmp = new array[0..rp]		// 申请一个大小跟A[p..r]一样的
  while i <= q AND j <= r do {
  	if A[i] <= A[j] {
  		tmp[k++] = A[i++]   // i++等于i:i+1
  	} else {
  		tmp[k++] = A[j++]
  	}
  }
  
  // 判断哪个子数组有剩余的数据
  var start := i, end := q
  if j <= r then start := j, end := r
  
  // 将剩余的数据拷贝到临时数据tmp
  while start <= end do {
  	tmp[k++] = A[start++]
  }
  // 将tmp中的数组拷贝回A[p..r]
  for i:=0 to r-p do {
  	A[p+1] = tmp[i]
  }
}
```











