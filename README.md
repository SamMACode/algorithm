# 数据结构与算法之美

> 数据结构与算法是大学的基础课程，在平时开发用到的各种框架、中间件和底层系统，比如`Spring`、`RPC`框架、消息中间件、`Redis`等等。在这些基础框架中，一般都揉合了很多基础数据结构和算法的设计思想。借用争哥的话 "数据结构和算法这个东西，如果你不去学，可能这辈子真的用不到，也感受不到它的好。但是一旦掌握，你就会常常被它的强大威力所折服。"

## 复杂度分析：空间复杂度与时间复杂度

从`CPU`的角度来看，程序中每行代码的执行都是类似的操作：读数据-运算-写数据。尽管每行代码对应的`CPU`执行的个数、执行的时间都不一样。但是，只是粗略估计可以假设每行代码执行的时间都一样，为`unit_time`。可以得到规律，所有代码的执行时间`T(n)`与每行代码的执行次数`n`成正比。可以将这个规律总结为一个公式：

```
T(n) = O(f(n))
```

解释下这个公式，其中`T(n)`表示代码总的执行时间；`n`表示数据规模的大小；`f(n)`表示每行代码执行的次数总和。因为这是一个公式，所以使用函数`f(n)`表示。公式中的`O`，表示代码的执行时间与`T(n)`与`f(n)`表达式成正比。对于`T(n)=O(2n+2)`就是大`O`时间复杂度表示法。大`O`时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势。所以，也叫做渐进时间复杂度（`asymptotic time complexity`）。

几种常见时间复杂度实例分析：

* `O(1)` 一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是`O(1)`；
* `O(logn)、O(nlogn)`，`O(nlogn)` 是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 `O(nlogn)`；
* `O(m+n)、O(m*n)`，在无法评估`m`和`n`这两个数据规模时，所以我们在表示复杂度的时候，就不能简单地利用加法规则，省掉其中一个。可以使用时间复杂度`O(m+n)`来表示；

类似于时间复杂度，空间复杂度表示算法的存储空间与数据规模之间的增长关系。

```java
int find(int[] array, int length, int x) {
  int pos = -1;
  for (int i = 0; i < length; ++i) {
    if (array[i] == x) {
      pos = i;
      break;
    }
  }
  return pos;
}
```

函数`find`用于在数组中根据`x`找到其在`array`中的下标位置，元素`x`在数组中位置是任意的。当`x`是位于数组的第一个元素，则只需遍历一次就可以，剩余的`n-1`个元素不用再遍历，时间复杂度为`O(1)`。若`x`不再数组中，则需要遍历数组中所有的元素，时间度就变为了`O(n)`。这就引入了**最好情况时间复杂度**、**最坏情况时间复杂度** 的概念。

## 线性表结构：数组、链表、队列、栈

数组（`array`）是一种线性表数据结构，它使用一组连续的内存空间，来存储一组具有相同类型的数据。线性表（`linear list`）就是数据拍成像一条线一样的结构，每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。

```
a[i]_address = base_address + i * data_type_size;
```

对于数组类型中，计算机会分配一段连续的内存空间。例如内存块的首地址为`base_address = 1000`，访问元素内存可根据`base_address`、要访问的下标、`type`占据字节数计算要访问的下标数据。关于数组下标为什么从`0`开始的解释是：如果数组从 1 开始计数，那我们计算数组元素`a[k]`的内存地址就会变为`a[k]_address = base_address + (k-1)*type_size`，每次随机访问数组都多了一次减法运算，对于`CPU`来说就是多了一次减法指令。

用链表实现`LRU`算法思路，维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历：

1. 如果数据之前已经缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部；
2. 若此数据没有缓存在链表中，又可以分为两种情况：
   * 要是缓存未满，则直接将此结点插入到链表的头部；
   * 缓存空间已满，则链表尾部节点删除，将新的数据结点插入到链表的头部；

优化：不论缓存有没有满，我们都要遍历一遍链表，所以这种基于链表的实现思路，缓存访问的时间复杂度是`O(n)`。可以引入散列表`HashTable`来记录每个元素的位置，将缓存访问的时间复杂度降低到`O(1)`。





