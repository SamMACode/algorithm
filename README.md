# 数据结构与算法之美

> 数据结构与算法是大学的基础课程，在平时开发用到的各种框架、中间件和底层系统，比如`Spring`、`RPC`框架、消息中间件、`Redis`等等。在这些基础框架中，一般都柔和了很多基础数据结构和算法的设计思想。借用争哥的话 "数据结构和算法这个东西，如果你不去学，可能这辈子真的用不到，也感受不到它的好。但是一旦掌握，你就会常常被它的强大威力所折服。"

## 复杂度分析：空间复杂度与时间复杂度

从`CPU`的角度来看，程序中每行代码的执行都是类似的操作：读数据-运算-写数据。尽管每行代码对应的`CPU`执行的个数、执行的时间都不一样。但是，只是粗略估计可以假设每行代码执行的时间都一样，为`unit_time`。可以得到规律，所有代码的执行时间`T(n)`与每行代码的执行次数`n`成正比。可以将这个规律总结为一个公式：

```
T(n) = O(f(n))
```

解释下这个公式，其中`T(n)`表示代码总的执行时间；`n`表示数据规模的大小；`f(n)`表示每行代码执行的次数总和。因为这是一个公式，所以使用函数`f(n)`表示。公式中的`O`，表示代码的执行时间与`T(n)`与`f(n)`表达式成正比。对于`T(n)=O(2n+2)`就是大`O`时间复杂度表示法。大`O`时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势。所以，也叫做渐进时间复杂度（`asymptotic time complexity`）。

几种常见时间复杂度实例分析：

* `O(1)` 一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是`O(1)`；
* `O(logn)、O(nlogn)`，`O(nlogn)` 是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 `O(nlogn)`；
* `O(m+n)、O(m*n)`，在无法评估`m`和`n`这两个数据规模时，所以我们在表示复杂度的时候，就不能简单地利用加法规则，省掉其中一个。可以使用时间复杂度`O(m+n)`来表示；

类似于时间复杂度，空间复杂度表示算法的存储空间与数据规模之间的增长关系。